{% extends 'base.html' %}
{% load static %}

{% block title %}BattyCoda - Segment Recording{% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="{% url 'battycoda_app:recording_list' %}">Recordings</a></li>
                <li class="breadcrumb-item"><a href="{% url 'battycoda_app:recording_detail' recording_id=recording.id %}">{{ recording.name }}</a></li>
                <li class="breadcrumb-item active" aria-current="page">Segment</li>
            </ol>
        </nav>
        <div class="btn-group" role="group">
            <button id="create-tasks-btn" class="btn btn-success" {% if not segments %}disabled{% endif %}>
                <i class="fas fa-tag"></i> Create Classification
            </button>
            {% if recording.segmentation %}
            <a href="{% url 'battycoda_app:create_detection_run_for_segmentation' segmentation_id=recording.segmentation.id %}" class="btn btn-success">
                <i class="fas fa-tag"></i> Run Classification
            </a>
            {% endif %}
            <a href="{% url 'battycoda_app:auto_segment_recording' recording_id=recording.id %}" class="btn btn-info">
                <i class="fas fa-magic"></i> Auto Segment
            </a>
            <a href="{% url 'battycoda_app:upload_pickle_segments' recording_id=recording.id %}" class="btn btn-primary">
                <i class="fas fa-file-upload"></i> Upload Pickle
            </a>
            <a href="{% url 'battycoda_app:batch_segmentation' %}" class="btn btn-secondary">
                <i class="fas fa-tasks"></i> Segmentation Jobs
            </a>
            <a href="{% url 'battycoda_app:recording_detail' recording_id=recording.id %}" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left"></i> Back to Recording
            </a>
        </div>
    </div>

    {% if messages %}
    <div class="messages mb-4">
        {% for message in messages %}
        <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
            {{ message }}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>
        {% endfor %}
    </div>
    {% endif %}

    <div class="row">
        <!-- Waveform and segmentation tools -->
        <div class="col-lg-8">
            <!-- Include the reusable waveform player with selection and zoom enabled -->
            {% include "recordings/includes/waveform_player.html" with recording=recording container_id="segment-waveform" height=300 allow_selection=True show_zoom=True segments=segments_json %}
            
            <!-- Segmentation actions -->
            <div class="card bg-dark mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Segmentation Actions</h5>
                    {% if active_segmentation %}
                    <span class="badge bg-primary">{{ active_segmentation.name }}</span>
                    {% endif %}
                </div>
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="btn-group">
                            <button id="add-segment-btn" class="btn btn-success">
                                <i class="fas fa-plus"></i> Add Segment
                            </button>
                        </div>
                        
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="auto-segment-toggle">
                            <label class="form-check-label" for="auto-segment-toggle">Auto-segment on play</label>
                        </div>
                    </div>
                    
                    {% if all_segmentations.count > 1 %}
                    <div class="mt-3">
                        <label for="segmentation-selector" class="form-label">Active Segmentation:</label>
                        <select id="segmentation-selector" class="form-select bg-dark text-light border-secondary">
                            {% for segmentation in all_segmentations %}
                            <option value="{{ segmentation.id }}" {% if active_segmentation and active_segmentation.id == segmentation.id %}selected{% endif %}>
                                {{ segmentation.name }} 
                                {% if segmentation.algorithm %}({{ segmentation.algorithm }}){% endif %}
                                {% if segmentation.is_active %}[Active]{% endif %}
                            </option>
                            {% endfor %}
                        </select>
                        <div class="d-grid mt-2">
                            <button id="switch-segmentation-btn" class="btn btn-outline-primary btn-sm">
                                <i class="fas fa-exchange-alt"></i> Switch Segmentation
                            </button>
                        </div>
                    </div>
                    {% endif %}
                </div>
            </div>
            
            <!-- Spectrogram visualization - currently disabled -->
            <div class="card bg-dark mb-4" style="display: none;">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Spectrogram</h5>
                    <span id="spectrogram-status" class="badge bg-info">Disabled</span>
                </div>
                <div class="card-body text-center p-1">
                    <div id="spectrogram-container" style="min-height: 200px; position: relative;">
                        <div class="alert alert-secondary">
                            Spectrogram generation is disabled for this view.
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Segments panel -->
        <div class="col-lg-4">
            <div class="card bg-dark">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <div>
                        <h5 class="mb-0">Segments</h5>
                    </div>
                    <div>
                        <span id="segments-count" class="badge bg-info me-2">{{ segments|length }}</span>
                        <button id="clear-segments-btn" class="btn btn-sm btn-danger" {% if not segments %}disabled{% endif %}>
                            <i class="fas fa-trash-alt"></i> Clear All
                        </button>
                    </div>
                </div>
                <div class="card-body p-0" style="max-height: 600px; overflow-y: auto;">
                    <div id="segments-container">
                        {% if segments %}
                            <table class="table table-dark table-hover table-striped mb-0">
                                <thead>
                                    <tr>
                                        <th>#</th>
                                        <th>Time Range</th>
                                        <th>Duration</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="segments-list">
                                    {% for segment in segments %}
                                    <tr id="segment-row-{{ segment.id }}" data-segment-id="{{ segment.id }}">
                                        <td>{{ segment.id }}</td>
                                        <td>{{ segment.onset|floatformat:2 }}s - {{ segment.offset|floatformat:2 }}s</td>
                                        <td>{{ segment.duration|floatformat:2 }}s</td>
                                        <td>
                                            <div class="btn-group btn-group-sm">
                                                <button class="btn btn-outline-primary play-segment-btn" 
                                                        data-onset="{{ segment.onset }}" 
                                                        data-offset="{{ segment.offset }}">
                                                    <i class="fas fa-play"></i>
                                                </button>
                                                <button class="btn btn-outline-warning edit-segment-btn" 
                                                        data-segment-id="{{ segment.id }}"
                                                        data-segment-name="{{ segment.name|default:'' }}"
                                                        data-segment-onset="{{ segment.onset }}"
                                                        data-segment-offset="{{ segment.offset }}"
                                                        data-segment-notes="{{ segment.notes|default:'' }}">
                                                    <i class="fas fa-edit"></i>
                                                </button>
                                                <button class="btn btn-outline-danger delete-segment-btn" 
                                                        data-segment-id="{{ segment.id }}">
                                                    <i class="fas fa-trash-alt"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        {% else %}
                            <div id="no-segments-message" class="text-center p-4">
                                <div class="mb-3">
                                    <i class="fas fa-cut fa-4x text-muted"></i>
                                </div>
                                <h5>No segments found</h5>
                                <p class="text-muted">Create segments by selecting regions on the waveform</p>
                            </div>
                        {% endif %}
                    </div>
                </div>
            </div>
            
            <!-- Segment form card (initially hidden) -->
            <div id="segment-form-card" class="card bg-dark mt-4" style="display: none;">
                <div class="card-header">
                    <h5 id="segment-form-title" class="mb-0">Add New Segment</h5>
                </div>
                <div class="card-body">
                    <form id="segment-form">
                        {% csrf_token %}
                        <input type="hidden" id="segment-id-input" name="segment_id" value="">
                        
                        <div class="mb-3">
                            <label for="segment-name-input" class="form-label">Name (optional)</label>
                            <input type="text" class="form-control bg-dark text-light border-secondary" id="segment-name-input" name="name" placeholder="e.g., Call 1">
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-6">
                                <label for="segment-onset-input" class="form-label">Start Time (s)*</label>
                                <input type="number" class="form-control bg-dark text-light border-secondary" id="segment-onset-input" name="onset" step="0.01" required>
                            </div>
                            <div class="col-6">
                                <label for="segment-offset-input" class="form-label">End Time (s)*</label>
                                <input type="number" class="form-control bg-dark text-light border-secondary" id="segment-offset-input" name="offset" step="0.01" required>
                            </div>
                        </div>
                        
                        
                        <div class="mb-3">
                            <label for="segment-notes-input" class="form-label">Notes</label>
                            <textarea class="form-control bg-dark text-light border-secondary" id="segment-notes-input" name="notes" rows="2"></textarea>
                        </div>
                        
                        <div class="d-flex justify-content-end gap-2">
                            <button type="button" id="cancel-segment-btn" class="btn btn-outline-secondary">Cancel</button>
                            <button type="submit" id="save-segment-btn" class="btn btn-primary">Save Segment</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Confirm Clear Segments Modal -->
<div class="modal fade" id="clear-segments-modal" tabindex="-1" aria-labelledby="clear-segments-modal-label" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content bg-dark text-light">
            <div class="modal-header bg-danger text-white">
                <h5 class="modal-title" id="clear-segments-modal-label">Confirm Delete All Segments</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete all segments? This action cannot be undone.</p>
                <p>If segments have associated tasks, the tasks will be disconnected from their source segments.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" id="confirm-clear-segments-btn" class="btn btn-danger">Delete All Segments</button>
            </div>
        </div>
    </div>
</div>

<!-- Create Tasks Modal -->
<div class="modal fade" id="create-tasks-modal" tabindex="-1" aria-labelledby="create-tasks-modal-label" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content bg-dark text-light">
            <div class="modal-header">
                <h5 class="modal-title" id="create-tasks-modal-label">Run Classification</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>This will take you to the algorithm selection page where you can run automated classification on all segments.</p>
                <p>You'll be able to choose which classification algorithm to use for these segments.</p>
                <hr>
                <p>Number of segments to classify: <span id="create-tasks-count" class="badge bg-info">{{ segments|length }}</span></p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <a href="{% url 'battycoda_app:create_detection_run_for_segmentation' segmentation_id=active_segmentation.id %}" class="btn btn-success">Select Classification Algorithm</a>
            </div>
        </div>
    </div>
</div>

{% block extra_scripts %}
<!-- Include the waveform player script -->
<script src="{% static 'js/waveform_player.js' %}"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Get the waveform elements from our component
    const audioPlayer = document.getElementById('segment-waveform-audio');
    const waveformContainer = document.getElementById('segment-waveform');
    const selectionRangeEl = document.getElementById('segment-waveform-selection-range');
    
    // Segment UI elements
    const segmentsContainer = document.getElementById('segments-container');
    let segmentsList = document.getElementById('segments-list');
    let noSegmentsMessage = document.getElementById('no-segments-message');
    const segmentsCountBadge = document.getElementById('segments-count');
    const addSegmentBtn = document.getElementById('add-segment-btn');
    const clearSegmentsBtn = document.getElementById('clear-segments-btn');
    const createTasksBtn = document.getElementById('create-tasks-btn');
    
    // Form elements
    const segmentFormCard = document.getElementById('segment-form-card');
    const segmentForm = document.getElementById('segment-form');
    const segmentFormTitle = document.getElementById('segment-form-title');
    const segmentIdInput = document.getElementById('segment-id-input');
    const segmentNameInput = document.getElementById('segment-name-input');
    const segmentOnsetInput = document.getElementById('segment-onset-input');
    const segmentOffsetInput = document.getElementById('segment-offset-input');
    const segmentNotesInput = document.getElementById('segment-notes-input');
    const cancelSegmentBtn = document.getElementById('cancel-segment-btn');
    const autoSegmentToggle = document.getElementById('auto-segment-toggle');
    
    // Modal buttons
    const confirmClearSegmentsBtn = document.getElementById('confirm-clear-segments-btn');
    
    // State
    let duration = {{ recording.duration|default:0 }};
    let segments = [];
    let selectionStart = null;
    let selectionEnd = null;
    
    // Initialize segments from server data
    {% for segment in segments %}
    segments.push({
        id: {{ segment.id }},
        name: "{{ segment.name|default:'' }}",
        onset: {{ segment.onset }},
        offset: {{ segment.offset }},
        notes: "{{ segment.notes|default:'' }}"
    });
    {% endfor %}
    
    // Add a new segment
    async function addSegment(segment) {
        try {
            const formData = new FormData();
            formData.append('name', segment.name || '');
            formData.append('onset', segment.onset);
            formData.append('offset', segment.offset);
            formData.append('notes', segment.notes || '');
            
            const response = await fetch("{% url 'battycoda_app:add_segment' recording_id=recording.id %}", {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                }
            });
            
            const data = await response.json();
            if (data.success) {
                // Add the new segment with ID from server
                segments.push({
                    id: data.segment.id,
                    name: segment.name || '',
                    onset: segment.onset,
                    offset: segment.offset,
                    notes: segment.notes || ''
                });
                
                // Add row to table if table exists
                if (segmentsList) {
                    const row = document.createElement('tr');
                    row.id = `segment-row-${data.segment.id}`;
                    row.dataset.segmentId = data.segment.id;
                    row.innerHTML = `
                        <td>${data.segment.id}</td>
                        <td>${data.segment.onset.toFixed(2)}s - ${data.segment.offset.toFixed(2)}s</td>
                        <td>${(data.segment.offset - data.segment.onset).toFixed(2)}s</td>
                        <td>
                            <div class="btn-group btn-group-sm">
                                <button class="btn btn-outline-primary play-segment-btn" 
                                        data-onset="${data.segment.onset}" 
                                        data-offset="${data.segment.offset}">
                                    <i class="fas fa-play"></i>
                                </button>
                                <button class="btn btn-outline-warning edit-segment-btn" 
                                        data-segment-id="${data.segment.id}"
                                        data-segment-name="${data.segment.name || ''}"
                                        data-segment-onset="${data.segment.onset}"
                                        data-segment-offset="${data.segment.offset}"
                                        data-segment-notes="${data.segment.notes || ''}">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-outline-danger delete-segment-btn" 
                                        data-segment-id="${data.segment.id}">
                                    <i class="fas fa-trash-alt"></i>
                                </button>
                            </div>
                        </td>
                    `;
                    segmentsList.appendChild(row);
                    
                    // Add event listeners to buttons
                    addSegmentButtonListeners(row);
                }
                
                // Update display
                updateSegmentsDisplay();
                
                return data.segment;
            } else {
                throw new Error(data.errors || 'Failed to add segment');
            }
        } catch (error) {
            console.error('Error adding segment:', error);
            alert('Error adding segment: ' + error.message);
            return null;
        }
    }
    
    // Edit a segment
    async function editSegment(segment) {
        try {
            const formData = new FormData();
            formData.append('name', segment.name || '');
            formData.append('onset', segment.onset);
            formData.append('offset', segment.offset);
            formData.append('notes', segment.notes || '');
            
            const response = await fetch(`{% url 'battycoda_app:edit_segment' segment_id=0 %}`.replace('0', segment.id), {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                }
            });
            
            const data = await response.json();
            if (data.success) {
                // Update the segment in the array
                const index = segments.findIndex(s => s.id === segment.id);
                if (index !== -1) {
                    segments[index] = {
                        id: segment.id,
                        name: segment.name || '',
                        onset: segment.onset,
                        offset: segment.offset,
                        notes: segment.notes || ''
                    };
                }
                
                // Update row in table if it exists
                const row = document.getElementById(`segment-row-${segment.id}`);
                if (row) {
                    row.cells[1].textContent = `${data.segment.onset.toFixed(2)}s - ${data.segment.offset.toFixed(2)}s`;
                    row.cells[2].textContent = `${(data.segment.offset - data.segment.onset).toFixed(2)}s`;
                    
                    // Update data attributes for buttons
                    const editBtn = row.querySelector('.edit-segment-btn');
                    if (editBtn) {
                        editBtn.dataset.segmentName = segment.name || '';
                        editBtn.dataset.segmentOnset = data.segment.onset;
                        editBtn.dataset.segmentOffset = data.segment.offset;
                        editBtn.dataset.segmentNotes = segment.notes || '';
                    }
                    
                    // Update play button data
                    const playBtn = row.querySelector('.play-segment-btn');
                    if (playBtn) {
                        playBtn.dataset.onset = data.segment.onset;
                        playBtn.dataset.offset = data.segment.offset;
                    }
                }
                
                // Update display
                updateSegmentsDisplay();
                
                return data.segment;
            } else {
                throw new Error(data.errors || 'Failed to update segment');
            }
        } catch (error) {
            console.error('Error updating segment:', error);
            alert('Error updating segment: ' + error.message);
            return null;
        }
    }
    
    // Delete a segment
    async function deleteSegment(segmentId) {
        try {
            const response = await fetch(`{% url 'battycoda_app:delete_segment' segment_id=0 %}`.replace('0', segmentId), {
                method: 'POST',
                headers: {
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                }
            });
            
            const data = await response.json();
            if (data.success) {
                // Remove the segment from the array
                segments = segments.filter(s => s.id !== parseInt(segmentId));
                
                // Remove row from table if it exists
                const row = document.getElementById(`segment-row-${segmentId}`);
                if (row) {
                    row.remove();
                }
                
                // Update display
                updateSegmentsDisplay();
                
                // Explicitly update waveform player
                if (window.waveformPlayers && window.waveformPlayers['segment-waveform']) {
                    const waveformSegments = segments.map(segment => ({
                        id: segment.id,
                        onset: segment.onset,
                        offset: segment.offset
                    }));
                    window.waveformPlayers['segment-waveform'].setSegments(waveformSegments);
                }
                
                console.log(`Segment ${segmentId} deleted. Remaining segments:`, segments);
                
                return true;
            } else {
                throw new Error(data.error || 'Failed to delete segment');
            }
        } catch (error) {
            console.error('Error deleting segment:', error);
            alert('Error deleting segment: ' + error.message);
            return false;
        }
    }
    
    // Update segments display
    function updateSegmentsDisplay() {
        // Update count
        segmentsCountBadge.textContent = segments.length;
        
        // Toggle visibility of no segments message and clear button
        if (segments.length === 0) {
            // No segments case - show message
            segmentsContainer.innerHTML = '';
            const msgDiv = document.createElement('div');
            msgDiv.id = 'no-segments-message';
            msgDiv.className = 'text-center p-4';
            msgDiv.innerHTML = `
                <div class="mb-3">
                    <i class="fas fa-cut fa-4x text-muted"></i>
                </div>
                <h5>No segments found</h5>
                <p class="text-muted">Create segments by selecting regions on the waveform</p>
            `;
            segmentsContainer.appendChild(msgDiv);
            
            // Update reference to no segments message
            noSegmentsMessage = msgDiv;
            
            // Disable buttons
            clearSegmentsBtn.disabled = true;
            createTasksBtn.disabled = true;
        } else {
            // Check if we need to create a new table (no segments -> segments)
            if (!document.querySelector('#segments-container table')) {
                // Remove no segments message if it exists
                if (noSegmentsMessage) {
                    noSegmentsMessage.remove();
                    noSegmentsMessage = null;
                }
                
                // Create table structure
                segmentsContainer.innerHTML = '';
                const table = document.createElement('table');
                table.className = 'table table-dark table-hover table-striped mb-0';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Time Range</th>
                            <th>Duration</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="segments-list"></tbody>
                `;
                segmentsContainer.appendChild(table);
                
                // Update reference to segments list
                segmentsList = document.getElementById('segments-list');
                
                // Re-add all segments to the new table
                segments.forEach(segment => {
                    const row = document.createElement('tr');
                    row.id = `segment-row-${segment.id}`;
                    row.dataset.segmentId = segment.id;
                    row.innerHTML = `
                        <td>${segment.id}</td>
                        <td>${segment.onset.toFixed(2)}s - ${segment.offset.toFixed(2)}s</td>
                        <td>${(segment.offset - segment.onset).toFixed(2)}s</td>
                        <td>
                            <div class="btn-group btn-group-sm">
                                <button class="btn btn-outline-primary play-segment-btn" 
                                        data-onset="${segment.onset}" 
                                        data-offset="${segment.offset}">
                                    <i class="fas fa-play"></i>
                                </button>
                                <button class="btn btn-outline-warning edit-segment-btn" 
                                        data-segment-id="${segment.id}"
                                        data-segment-name="${segment.name || ''}"
                                        data-segment-onset="${segment.onset}"
                                        data-segment-offset="${segment.offset}"
                                        data-segment-notes="${segment.notes || ''}">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-outline-danger delete-segment-btn" 
                                        data-segment-id="${segment.id}">
                                    <i class="fas fa-trash-alt"></i>
                                </button>
                            </div>
                        </td>
                    `;
                    segmentsList.appendChild(row);
                    
                    // Add event listeners to buttons
                    addSegmentButtonListeners(row);
                });
            }
            
            // Enable buttons
            clearSegmentsBtn.disabled = false;
            createTasksBtn.disabled = false;
        }
        
        // Update the waveform player with the new segments
        if (window.waveformPlayers && window.waveformPlayers['segment-waveform']) {
            const waveformSegments = segments.map(segment => ({
                id: segment.id,
                onset: segment.onset,
                offset: segment.offset
            }));
            window.waveformPlayers['segment-waveform'].setSegments(waveformSegments);
        }
    }
    
    // Add event listeners to segment table row buttons
    function addSegmentButtonListeners(row) {
        // Play button
        const playBtn = row.querySelector('.play-segment-btn');
        if (playBtn) {
            playBtn.addEventListener('click', function() {
                const onset = parseFloat(this.dataset.onset);
                const offset = parseFloat(this.dataset.offset);
                
                // Set current time and play
                audioPlayer.currentTime = onset;
                audioPlayer.play();
                
                // Stop at the end of the segment
                const duration = offset - onset;
                setTimeout(() => {
                    if (audioPlayer.currentTime >= offset) {
                        audioPlayer.pause();
                    }
                }, duration * 1000);
            });
        }
        
        // Edit button
        const editBtn = row.querySelector('.edit-segment-btn');
        if (editBtn) {
            editBtn.addEventListener('click', function() {
                // Set form values
                segmentIdInput.value = this.dataset.segmentId;
                segmentNameInput.value = this.dataset.segmentName || '';
                segmentOnsetInput.value = this.dataset.segmentOnset;
                segmentOffsetInput.value = this.dataset.segmentOffset;
                segmentNotesInput.value = this.dataset.segmentNotes || '';
                
                // Show form
                segmentFormTitle.textContent = 'Edit Segment';
                segmentFormCard.style.display = 'block';
                
                // Scroll to form
                segmentFormCard.scrollIntoView({ behavior: 'smooth' });
            });
        }
        
        // Delete button
        const deleteBtn = row.querySelector('.delete-segment-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', function() {
                if (confirm('Are you sure you want to delete this segment?')) {
                    deleteSegment(this.dataset.segmentId);
                }
            });
        }
    }
    
    // Check for selection changes from the waveform component
    function checkForSelectionChanges() {
        if (selectionRangeEl) {
            const selectionText = selectionRangeEl.textContent;
            if (selectionText && selectionText !== 'No Selection') {
                // Parse selection from the text "Selection: 1.23s - 4.56s (3.33s)"
                const match = selectionText.match(/Selection: (\d+\.\d+)s - (\d+\.\d+)s/);
                if (match) {
                    selectionStart = parseFloat(match[1]);
                    selectionEnd = parseFloat(match[2]);
                }
            } else if (selectionText === 'No Selection') {
                selectionStart = null;
                selectionEnd = null;
            }
        }
    }
    
    // Add segment button
    addSegmentBtn.addEventListener('click', function() {
        // First check if the selection has been updated
        checkForSelectionChanges();
        
        if (selectionStart !== null && selectionEnd !== null) {
            // Set form values
            segmentIdInput.value = '';
            segmentNameInput.value = '';
            segmentOnsetInput.value = selectionStart.toFixed(2);
            segmentOffsetInput.value = selectionEnd.toFixed(2);
            segmentNotesInput.value = '';
            
            // Show form
            segmentFormTitle.textContent = 'Add New Segment';
            segmentFormCard.style.display = 'block';
            
            // Scroll to form
            segmentFormCard.scrollIntoView({ behavior: 'smooth' });
        } else {
            alert('Please select a region on the waveform first by setting start and end points.');
        }
    });
    
    // Segment form submission
    segmentForm.addEventListener('submit', async function(e) {
        e.preventDefault();
        
        // Validate form
        const onset = parseFloat(segmentOnsetInput.value);
        const offset = parseFloat(segmentOffsetInput.value);
        
        if (isNaN(onset) || isNaN(offset)) {
            alert('Start and end times must be valid numbers.');
            return;
        }
        
        if (onset >= offset) {
            alert('End time must be greater than start time.');
            return;
        }
        
        if (onset < 0 || offset > duration) {
            alert(`Time values must be between 0 and ${duration.toFixed(2)} seconds.`);
            return;
        }
        
        // Create segment object
        const segment = {
            name: segmentNameInput.value,
            onset: onset,
            offset: offset,
            notes: segmentNotesInput.value
        };
        
        // Add or update segment
        if (segmentIdInput.value) {
            // Edit existing segment
            segment.id = segmentIdInput.value;
            await editSegment(segment);
        } else {
            // Add new segment
            await addSegment(segment);
        }
        
        // Hide form
        segmentFormCard.style.display = 'none';
    });
    
    // Cancel segment button
    cancelSegmentBtn.addEventListener('click', function() {
        segmentFormCard.style.display = 'none';
    });
    
    // Clear segments button
    clearSegmentsBtn.addEventListener('click', function() {
        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('clear-segments-modal'));
        modal.show();
    });
    
    // Confirm clear segments button
    confirmClearSegmentsBtn.addEventListener('click', async function() {
        // Delete all segments
        const promises = segments.map(segment => deleteSegment(segment.id));
        await Promise.all(promises);
        
        // Hide modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('clear-segments-modal'));
        modal.hide();
    });
    
    // Create tasks button
    createTasksBtn.addEventListener('click', function() {
        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('create-tasks-modal'));
        document.getElementById('create-tasks-count').textContent = segments.length;
        modal.show();
    });
    
    // Segmentation switcher
    const switchSegmentationBtn = document.getElementById('switch-segmentation-btn');
    const segmentationSelector = document.getElementById('segmentation-selector');
    
    if (switchSegmentationBtn && segmentationSelector) {
        switchSegmentationBtn.addEventListener('click', async function() {
            const segmentationId = segmentationSelector.value;
            if (!segmentationId) return;
            
            try {
                // Send request to activate the selected segmentation
                const response = await fetch(`{% url 'battycoda_app:activate_segmentation' segmentation_id=0 %}`.replace('0', segmentationId), {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });
                
                const data = await response.json();
                if (data.success) {
                    // Reload the page to see the new active segmentation
                    window.location.reload();
                } else {
                    throw new Error(data.message || 'Failed to switch segmentation');
                }
            } catch (error) {
                console.error('Error switching segmentation:', error);
                alert('Error switching segmentation: ' + error.message);
            }
        });
    }
    
    // Auto-segment toggle with waveform player
    if (autoSegmentToggle && audioPlayer) {
        let autoSegmentStart = null;
        
        audioPlayer.addEventListener('play', function() {
            if (autoSegmentToggle.checked) {
                autoSegmentStart = audioPlayer.currentTime;
            }
        });
        
        audioPlayer.addEventListener('pause', function() {
            if (autoSegmentToggle.checked && autoSegmentStart !== null) {
                const autoSegmentEnd = audioPlayer.currentTime;
                
                // Only create segment if it's at least 0.1 seconds long
                if (autoSegmentEnd - autoSegmentStart >= 0.1) {
                    // Auto add segment
                    const segment = {
                        name: '',
                        onset: autoSegmentStart,
                        offset: autoSegmentEnd,
                            notes: ''
                    };
                    
                    addSegment(segment);
                    autoSegmentStart = null;
                }
            }
        });
    }
    
    // Add event listeners to existing segment buttons
    if (segmentsList) {
        const rows = segmentsList.querySelectorAll('tr');
        rows.forEach(row => {
            addSegmentButtonListeners(row);
        });
    }
    
    // Initialize
    updateSegmentsDisplay();
});
</script>
{% endblock %}

{% endblock %}