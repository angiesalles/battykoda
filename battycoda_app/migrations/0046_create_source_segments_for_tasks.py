# Generated by Django 5.1.7 on 2025-03-28 02:10

import logging
from django.db import migrations

logger = logging.getLogger("battycoda.migrations")

def create_source_segments_for_tasks(apps, schema_editor):
    """
    Create source segments for all tasks that don't have one.
    This ensures every task has a source segment with proper recording and sample rate info.
    """
    Task = apps.get_model("battycoda_app", "Task")
    Segment = apps.get_model("battycoda_app", "Segment")
    Recording = apps.get_model("battycoda_app", "Recording")
    Segmentation = apps.get_model("battycoda_app", "Segmentation")
    
    # Get all tasks without source segments
    tasks_without_segments = Task.objects.filter(source_segment__isnull=True)
    total_tasks = tasks_without_segments.count()
    logger.info(f"Creating source segments for {total_tasks} tasks")
    
    # Default sample rate to use for all recordings
    default_sample_rate = 250000  # 250kHz - Typical high-quality bat recording rate
    
    updated_count = 0
    for task in tasks_without_segments:
        try:
            # First, check if this task's wav file corresponds to an existing recording
            # Use the batch wav_file if available
            wav_file_path = None
            if task.batch and task.batch.wav_file:
                wav_file_path = task.batch.wav_file.name
            else:
                wav_file_path = f"recordings/{task.wav_file_name}"
            
            # Look for a matching recording
            matching_recordings = Recording.objects.filter(wav_file=wav_file_path)
            
            recording = None
            if matching_recordings.exists():
                # Use the existing recording
                recording = matching_recordings.first()
                logger.info(f"Found existing recording for task {task.id}: {recording.name}")
            else:
                # Create a new recording with this wav file
                if task.batch and task.batch.wav_file:
                    recording_name = f"Recording for {task.batch.name}"
                    recording = Recording.objects.create(
                        name=recording_name,
                        description=f"Automatically created from task batch {task.batch.name}",
                        wav_file=task.batch.wav_file,
                        species=task.species,
                        project=task.project,
                        group=task.group,
                        created_by=task.created_by,
                        sample_rate=default_sample_rate  # Use the default high sample rate
                    )
                    logger.info(f"Created new recording for task {task.id}: {recording.name}")
            
            if recording:
                # Create a segmentation for this recording if needed
                try:
                    segmentation = Segmentation.objects.filter(recording=recording, is_active=True).first()
                    if not segmentation:
                        # Create new active segmentation
                        segmentation = Segmentation.objects.create(
                            recording=recording,
                            name=f"Auto Segmentation for {recording.name}",
                            is_active=True,
                            status="completed",
                            progress=100,
                            created_by=recording.created_by
                        )
                        logger.info(f"Created new segmentation for recording {recording.id}")
                
                    # Create a segment for this task
                    segment = Segment.objects.create(
                        recording=recording,
                        segmentation=segmentation,
                        name=f"Segment for Task {task.id}",
                        onset=task.onset,
                        offset=task.offset,
                        created_by=task.created_by,
                        notes=task.notes,
                        task=task  # Link back to the task
                    )
                    
                    # Update counter
                    updated_count += 1
                    
                    # Add this segment to the count
                    segmentation.segments_created = segmentation.segments_created + 1
                    segmentation.save()
                    
                except Exception as seg_error:
                    logger.error(f"Error creating segmentation/segment for task {task.id}: {str(seg_error)}")
            else:
                logger.warning(f"Could not create recording for task {task.id}, no wav file available")
                
        except Exception as e:
            logger.error(f"Error processing task {task.id}: {str(e)}")
    
    logger.info(f"Successfully created {updated_count} source segments out of {total_tasks} tasks")

def reverse_source_segments(apps, schema_editor):
    """
    Reversible operation - remove segments created by this migration.
    This is a best effort since we can't really know which ones were created by this migration.
    """
    # We don't want to actually delete anything in the reverse migration
    pass

class Migration(migrations.Migration):
    dependencies = [
        ("battycoda_app", "0045_add_recording_sample_rate"),
    ]

    operations = [
        migrations.RunPython(
            create_source_segments_for_tasks,
            reverse_source_segments
        ),
    ]
